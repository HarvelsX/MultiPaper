From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Sun, 28 Nov 2021 22:07:06 +1000
Subject: [PATCH] Hurt external entities


diff --git a/src/main/java/net/minecraft/world/damagesource/DamageSource.java b/src/main/java/net/minecraft/world/damagesource/DamageSource.java
index 14fcfd7c1d3a62833978e163f4e0d6f9b2203042..498ac52c6c1de58de7959b708c4d0a43c65a6988 100644
--- a/src/main/java/net/minecraft/world/damagesource/DamageSource.java
+++ b/src/main/java/net/minecraft/world/damagesource/DamageSource.java
@@ -66,7 +66,7 @@ public class DamageSource {
         return this.causingEntity != this.directEntity;
     }
 
-    private DamageSource(Holder<DamageType> type, @Nullable Entity source, @Nullable Entity attacker, @Nullable Vec3 position) {
+    public DamageSource(Holder<DamageType> type, @Nullable Entity source, @Nullable Entity attacker, @Nullable Vec3 position) { // MultiPaper - make public
         this.type = type;
         this.causingEntity = attacker;
         this.directEntity = source;
diff --git a/src/main/java/net/minecraft/world/damagesource/DamageSources.java b/src/main/java/net/minecraft/world/damagesource/DamageSources.java
index 4604f8b38460e9113e966889a679d4547f24aff6..74f3017924e4dbccc941bfbe4e33c7a8f0db6269 100644
--- a/src/main/java/net/minecraft/world/damagesource/DamageSources.java
+++ b/src/main/java/net/minecraft/world/damagesource/DamageSources.java
@@ -1,6 +1,8 @@
 package net.minecraft.world.damagesource;
 
 import javax.annotation.Nullable;
+
+import net.minecraft.core.Holder;
 import net.minecraft.core.Registry;
 import net.minecraft.core.RegistryAccess;
 import net.minecraft.core.registries.Registries;
@@ -87,6 +89,12 @@ public class DamageSources {
         return new DamageSource(this.damageTypes.getHolderOrThrow(key), source, attacker);
     }
 
+    // MultiPaper start
+    public Holder<DamageType> getDamageType(ResourceKey<DamageType> key) {
+        return this.damageTypes.getHolderOrThrow(key);
+    }
+    // MultiPaper end
+
     public DamageSource inFire() {
         return this.inFire;
     }
diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index 75810b5965e45934af2c6961d581aa7285fa4d37..843a0983b59aaaa30315f9da2832f598a542a79f 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -141,8 +141,11 @@ import org.bukkit.event.entity.EntityRegainHealthEvent;
 import org.bukkit.event.entity.EntityResurrectEvent;
 import org.bukkit.event.entity.EntityTeleportEvent;
 import org.bukkit.event.player.PlayerItemConsumeEvent;
+import puregero.multipaper.ExternalServerConnection;
 import puregero.multipaper.MultiPaper;
+import puregero.multipaper.MultiPaperEntityInteractHandler;
 import puregero.multipaper.externalserverprotocol.EntityUpdatePacket;
+import puregero.multipaper.externalserverprotocol.HurtEntityPacket;
 // CraftBukkit end
 
 
@@ -1418,6 +1421,15 @@ public abstract class LivingEntity extends Entity implements Attackable {
 
     @Override
     public boolean hurt(DamageSource source, float amount) {
+        // MultiPaper start
+        ExternalServerConnection owner = MultiPaperEntityInteractHandler.getOwner(this);
+        if (owner != null) {
+            owner.send(new HurtEntityPacket(this, source, amount, CraftEventFactory.entityDamage, CraftEventFactory.blockDamage));
+            CraftEventFactory.entityDamage = null;
+            CraftEventFactory.blockDamage = null;
+            return false;
+        }
+        // MultiPaper end
         if (this.isInvulnerableTo(source)) {
             return false;
         } else if (this.level().isClientSide) {
diff --git a/src/main/java/puregero/multipaper/ExternalPlayer.java b/src/main/java/puregero/multipaper/ExternalPlayer.java
index af607456caeba614420e383dc380162886d7c622..4e6db03cac76778c4150e1229b33fe2b90d37040 100644
--- a/src/main/java/puregero/multipaper/ExternalPlayer.java
+++ b/src/main/java/puregero/multipaper/ExternalPlayer.java
@@ -10,13 +10,16 @@ import net.minecraft.network.syncher.EntityDataAccessor;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.server.network.ServerGamePacketListenerImpl;
+import net.minecraft.world.damagesource.DamageSource;
 import net.minecraft.world.level.GameType;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.bukkit.Bukkit;
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
 import puregero.multipaper.externalserverprotocol.EntityUpdatePacket;
+import puregero.multipaper.externalserverprotocol.HurtEntityPacket;
 
 import javax.annotation.Nullable;
 import java.net.InetSocketAddress;
@@ -124,4 +127,12 @@ public class ExternalPlayer extends ServerPlayer {
                     new ClientboundSetEntityDataPacket(getId(), Collections.singletonList(getEntityData().getItem(data).value()))));
         }
     }
+
+    @Override
+    public boolean hurt(DamageSource source, float amount) {
+        externalServerConnection.send(new HurtEntityPacket(this, source, amount, CraftEventFactory.entityDamage, CraftEventFactory.blockDamage));
+        CraftEventFactory.entityDamage = null;
+        CraftEventFactory.blockDamage = null;
+        return true;
+    }
 }
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
index ff5b08a3e27643b5e3153f3f058fd0a86090b347..aabc8ed6261846cbed62ab68c5d8ab8a135a0fed 100644
--- a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
@@ -44,6 +44,7 @@ public class ExternalServerPacketSerializer {
         addPacket(EntityRemovePacket.class, EntityRemovePacket::new);
         addPacket(PlayerActionOnEntityPacket.class, PlayerActionOnEntityPacket::new);
         addPacket(PlayerTouchEntityPacket.class, PlayerTouchEntityPacket::new);
+        addPacket(HurtEntityPacket.class, HurtEntityPacket::new);
     }
 
     private static void addPacket(Class<? extends ExternalServerPacket> clazz, Function<FriendlyByteBuf, ExternalServerPacket> deserializer) {
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/HurtEntityPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/HurtEntityPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..207e2596ec3525308d9143531dba1e180bb2fb83
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/HurtEntityPacket.java
@@ -0,0 +1,120 @@
+package puregero.multipaper.externalserverprotocol;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import net.minecraft.core.BlockPos;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.damagesource.DamageSource;
+import net.minecraft.world.entity.Entity;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.block.Block;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.block.CraftBlock;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.util.DamageSourceSerializer;
+
+import java.io.*;
+import java.util.UUID;
+
+public class HurtEntityPacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(HurtEntityPacket.class.getSimpleName());
+
+    private final String world;
+    private final UUID uuid;
+    private final ByteBuf sourceBytes;
+    private final float amount;
+    private final UUID entityDamageUuid;
+    private final BlockPos blockDamagePos;
+
+    public HurtEntityPacket(Entity entity, DamageSource source, float amount, Entity entityDamage, Block blockDamage) {
+        this.world = ((ServerLevel) entity.level()).convertable.getLevelId();
+        this.uuid = entity.getUUID();
+        this.amount = amount;
+        this.entityDamageUuid = entityDamage == null ? null : entityDamage.getUUID();
+        this.blockDamagePos = blockDamage == null ? null : ((CraftBlock) blockDamage).getPosition();
+
+        try {
+            FriendlyByteBuf out = new FriendlyByteBuf(Unpooled.buffer());
+            DamageSourceSerializer.serialize(source, out);
+            sourceBytes = out;
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+
+    }
+
+    public HurtEntityPacket(FriendlyByteBuf in) {
+        world = in.readUtf();
+        uuid = in.readUUID();
+        amount = in.readFloat();
+
+        if (in.readBoolean()) {
+            entityDamageUuid = in.readUUID();
+        } else {
+            entityDamageUuid = null;
+        }
+
+        if (in.readBoolean()) {
+            blockDamagePos = BlockPos.of(in.readLong());
+        } else {
+            blockDamagePos = null;
+        }
+
+        sourceBytes = in.readBytes(in.readableBytes());
+    }
+
+    @Override
+    public void write(FriendlyByteBuf out) {
+        out.writeUtf(world);
+        out.writeUUID(uuid);
+        out.writeFloat(amount);
+
+        out.writeBoolean(entityDamageUuid != null);
+        if (entityDamageUuid != null) {
+            out.writeUUID(entityDamageUuid);
+        }
+
+        out.writeBoolean(blockDamagePos != null);
+        if (blockDamagePos != null) {
+            out.writeLong(blockDamagePos.asLong());
+        }
+
+        out.writeBytes(sourceBytes);
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        MultiPaper.runSync(() -> {
+            try {
+                ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+                Entity entity = level.getEntity(uuid);
+                DamageSource source = DamageSourceSerializer.deserialize(entity, level, new FriendlyByteBuf(sourceBytes));
+                sourceBytes.release();
+
+                if (entity == null) {
+                    LOGGER.warn("Could not find entity " + uuid + " for damage source " + source.getMsgId());
+                    return;
+                }
+
+                Entity entityDamage = entityDamageUuid == null ? null : level.getEntity(entityDamageUuid);
+                Block blockDamage = blockDamagePos == null ? null : CraftBlock.at(level, blockDamagePos);
+
+                CraftEventFactory.entityDamage = entityDamage;
+                CraftEventFactory.blockDamage = blockDamage;
+
+                entity.hurt(source, amount);
+
+                CraftEventFactory.entityDamage = null;
+                CraftEventFactory.blockDamage = null;
+            } catch (IOException e) {
+                throw new RuntimeException(e);
+            }
+        });
+    }
+}
diff --git a/src/main/java/puregero/multipaper/util/DamageSourceSerializer.java b/src/main/java/puregero/multipaper/util/DamageSourceSerializer.java
new file mode 100644
index 0000000000000000000000000000000000000000..95b76a8d584a1b2fc0f73eb50d93768b3036a388
--- /dev/null
+++ b/src/main/java/puregero/multipaper/util/DamageSourceSerializer.java
@@ -0,0 +1,158 @@
+package puregero.multipaper.util;
+
+import com.google.common.base.CaseFormat;
+import net.minecraft.core.Holder;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.resources.ResourceKey;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.damagesource.DamageSource;
+import net.minecraft.world.damagesource.DamageType;
+import net.minecraft.world.damagesource.DamageTypes;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.phys.Vec3;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Modifier;
+import java.util.UUID;
+
+public class DamageSourceSerializer {
+
+    private static final Logger LOGGER = LogManager.getLogger(DamageSourceSerializer.class.getSimpleName());
+
+    /**
+     * Generate the switch statement used in deserialize
+     */
+    public static void main(String[] args) throws IllegalAccessException, InvocationTargetException {
+        StringBuilder s = new StringBuilder("return switch (msgId) {\n");
+        for (Field field : DamageTypes.class.getDeclaredFields()) {
+            if (Modifier.isStatic(field.getModifiers()) && ResourceKey.class.isAssignableFrom(field.getType())) {
+                String msgId = CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL, field.getName());
+                s.append("    case \"").append(msgId).append("\" -> DamageTypes.").append(field.getName()).append(";\n");
+            }
+        }
+        s.append("    default -> throw new IOException(\"Unknown damage cause msgId of \" + msgId);\n");
+        s.append("};");
+        System.out.println(s);
+    }
+
+    public static void serialize(DamageSource source, FriendlyByteBuf friendlyByteBuf) throws IOException {
+        friendlyByteBuf.writeUtf(source.getMsgId());
+
+        friendlyByteBuf.writeNullable(source.getEntity(), (byteBuf, entity) -> {
+            byteBuf.writeLong(entity.getUUID().getMostSignificantBits());
+            byteBuf.writeLong(entity.getUUID().getLeastSignificantBits());
+        });
+
+        friendlyByteBuf.writeNullable(source.getDirectEntity(), (byteBuf, directEntity) -> {
+            byteBuf.writeLong(directEntity.getUUID().getMostSignificantBits());
+            byteBuf.writeLong(directEntity.getUUID().getLeastSignificantBits());
+        });
+
+        friendlyByteBuf.writeNullable(source.getSourcePosition(), (byteBuf, vec3) -> {
+            byteBuf.writeDouble(vec3.x);
+            byteBuf.writeDouble(vec3.y);
+            byteBuf.writeDouble(vec3.z);
+        });
+
+        friendlyByteBuf.writeBoolean(source.isSweep());
+        friendlyByteBuf.writeBoolean(source.isMelting());
+        friendlyByteBuf.writeBoolean(source.isPoison());
+        friendlyByteBuf.writeBoolean(source.isCritical());
+    }
+
+    public static DamageSource deserialize(Entity entity, ServerLevel level, FriendlyByteBuf friendlyByteBuf) throws IOException {
+        String msgId = friendlyByteBuf.readUtf();
+
+        Entity causingEntity = friendlyByteBuf.readNullable(byteBuf -> {
+            UUID uuid = new UUID(byteBuf.readLong(), byteBuf.readLong());
+            Entity levelEntity = level.getEntity(uuid);
+            if (levelEntity == null) {
+                LOGGER.warn("Unknown entity for damage source " + msgId + " uuid=" + uuid);
+            }
+            return levelEntity;
+        });
+
+        Entity directEntity = friendlyByteBuf.readNullable(byteBuf -> {
+            UUID uuid = new UUID(byteBuf.readLong(), byteBuf.readLong());
+            Entity levelEntity = level.getEntity(uuid);
+            if (levelEntity == null) {
+                LOGGER.warn("Unknown direct entity for damage source " + msgId + " uuid=" + uuid);
+            }
+            return levelEntity;
+        });
+
+        Vec3 sourcePosition = friendlyByteBuf.readNullable(byteBuf -> new Vec3(byteBuf.readDouble(), byteBuf.readDouble(), byteBuf.readDouble()));
+
+        boolean sweep = friendlyByteBuf.readBoolean();
+        boolean melting = friendlyByteBuf.readBoolean();
+        boolean poison = friendlyByteBuf.readBoolean();
+        boolean critical = friendlyByteBuf.readBoolean();
+
+        return createDamageSource(entity.damageSources().getDamageType(getDamageTypeKey(msgId)), causingEntity, directEntity, sourcePosition, sweep, melting, poison, critical);
+    }
+
+    private static ResourceKey<DamageType> getDamageTypeKey(String msgId) throws IOException {
+        // Auto generated switch statement
+        return switch (msgId) {
+            case "inFire" -> DamageTypes.IN_FIRE;
+            case "lightningBolt" -> DamageTypes.LIGHTNING_BOLT;
+            case "onFire" -> DamageTypes.ON_FIRE;
+            case "lava" -> DamageTypes.LAVA;
+            case "hotFloor" -> DamageTypes.HOT_FLOOR;
+            case "inWall" -> DamageTypes.IN_WALL;
+            case "cramming" -> DamageTypes.CRAMMING;
+            case "drown" -> DamageTypes.DROWN;
+            case "starve" -> DamageTypes.STARVE;
+            case "cactus" -> DamageTypes.CACTUS;
+            case "fall" -> DamageTypes.FALL;
+            case "flyIntoWall" -> DamageTypes.FLY_INTO_WALL;
+            case "outOfWorld" -> DamageTypes.FELL_OUT_OF_WORLD;
+            case "generic" -> DamageTypes.GENERIC;
+            case "magic" -> DamageTypes.MAGIC;
+            case "wither" -> DamageTypes.WITHER;
+            case "dragonBreath" -> DamageTypes.DRAGON_BREATH;
+            case "dryOut" -> DamageTypes.DRY_OUT;
+            case "sweetBerryBush" -> DamageTypes.SWEET_BERRY_BUSH;
+            case "freeze" -> DamageTypes.FREEZE;
+            case "stalagmite" -> DamageTypes.STALAGMITE;
+            case "fallingBlock" -> DamageTypes.FALLING_BLOCK;
+            case "fallingAnvil" -> DamageTypes.FALLING_ANVIL;
+            case "fallingStalactite" -> DamageTypes.FALLING_STALACTITE;
+            case "sting" -> DamageTypes.STING;
+            case "mobAttack" -> DamageTypes.MOB_ATTACK;
+            case "mobAttackNoAggro" -> DamageTypes.MOB_ATTACK_NO_AGGRO;
+            case "playerAttack" -> DamageTypes.PLAYER_ATTACK;
+            case "arrow" -> DamageTypes.ARROW;
+            case "trident" -> DamageTypes.TRIDENT;
+            case "mobProjectile" -> DamageTypes.MOB_PROJECTILE;
+            case "fireworks" -> DamageTypes.FIREWORKS;
+            case "fireball" -> DamageTypes.FIREBALL;
+            case "unattributedFireball" -> DamageTypes.UNATTRIBUTED_FIREBALL;
+            case "witherSkull" -> DamageTypes.WITHER_SKULL;
+            case "thrown" -> DamageTypes.THROWN;
+            case "indirectMagic" -> DamageTypes.INDIRECT_MAGIC;
+            case "thorns" -> DamageTypes.THORNS;
+            case "explosion" -> DamageTypes.EXPLOSION;
+            case "playerExplosion" -> DamageTypes.PLAYER_EXPLOSION;
+            case "sonicBoom" -> DamageTypes.SONIC_BOOM;
+            case "badRespawnPoint" -> DamageTypes.BAD_RESPAWN_POINT;
+            default -> throw new IOException("Unknown damage cause msgId of " + msgId);
+        };
+    }
+
+    private static DamageSource createDamageSource(Holder<DamageType> damageType, Entity causingEntity, Entity directEntity, Vec3 sourcePosition, boolean sweep, boolean melting, boolean poison, boolean critical) {
+        DamageSource damageSource = new DamageSource(damageType, causingEntity, directEntity, sourcePosition);
+
+        if (sweep) damageSource.sweep();
+        if (melting) damageSource.melting();
+        if (poison) damageSource.poison();
+        if (critical) damageSource.critical();
+
+        return damageSource;
+    }
+
+}
