From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Wed, 13 Jul 2022 12:14:11 +1000
Subject: [PATCH] Sync game events


diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index 903e677385e1f477d7817b897627929d51964c1b..01bdf4d85ec839bf11a65ca477cc7d3e2877b340 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -185,6 +185,7 @@ import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet; // Paper
 import puregero.multipaper.MultiPaper;
 import puregero.multipaper.MultiPaperChunkHandler;
 import puregero.multipaper.MultiPaperEntitiesHandler;
+import puregero.multipaper.MultiPaperGameEventHandler;
 import puregero.multipaper.MultiPaperInactiveTracker;
 import puregero.multipaper.externalserverprotocol.SpawnUpdatePacket;
 import puregero.multipaper.externalserverprotocol.TimeUpdatePacket;
@@ -1046,6 +1047,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
                 LightningBolt entitylightning = (LightningBolt) EntityType.LIGHTNING_BOLT.create(this);
 
+
                 if (entitylightning != null) {
                     entitylightning.moveTo(Vec3.atBottomCenterOf(blockposition));
                     entitylightning.setVisualOnly(flag1);
diff --git a/src/main/java/net/minecraft/world/entity/animal/allay/Allay.java b/src/main/java/net/minecraft/world/entity/animal/allay/Allay.java
index 7166f4a39fd615e10d7b1f53c57363832a41f365..fe3928c73e7a4bf0c0cba38b417da9844593f3d3 100644
--- a/src/main/java/net/minecraft/world/entity/animal/allay/Allay.java
+++ b/src/main/java/net/minecraft/world/entity/animal/allay/Allay.java
@@ -70,6 +70,7 @@ import net.minecraft.world.level.gameevent.vibrations.VibrationSystem;
 import net.minecraft.world.phys.Vec3;
 import org.jetbrains.annotations.Nullable;
 import org.slf4j.Logger;
+import puregero.multipaper.MultiPaperGameEventHandler;
 
 public class Allay extends PathfinderMob implements InventoryCarrier, VibrationSystem {
 
@@ -87,7 +88,7 @@ public class Allay extends PathfinderMob implements InventoryCarrier, VibrationS
     protected static final ImmutableList<SensorType<? extends Sensor<? super Allay>>> SENSOR_TYPES = ImmutableList.of(SensorType.NEAREST_LIVING_ENTITIES, SensorType.NEAREST_PLAYERS, SensorType.HURT_BY, SensorType.NEAREST_ITEMS);
     protected static final ImmutableList<MemoryModuleType<?>> MEMORY_TYPES = ImmutableList.of(MemoryModuleType.PATH, MemoryModuleType.LOOK_TARGET, MemoryModuleType.NEAREST_VISIBLE_LIVING_ENTITIES, MemoryModuleType.WALK_TARGET, MemoryModuleType.CANT_REACH_WALK_TARGET_SINCE, MemoryModuleType.HURT_BY, MemoryModuleType.NEAREST_VISIBLE_WANTED_ITEM, MemoryModuleType.LIKED_PLAYER, MemoryModuleType.LIKED_NOTEBLOCK_POSITION, MemoryModuleType.LIKED_NOTEBLOCK_COOLDOWN_TICKS, MemoryModuleType.ITEM_PICKUP_COOLDOWN_TICKS, MemoryModuleType.IS_PANICKING, new MemoryModuleType[0]);
     public static final ImmutableList<Float> THROW_SOUND_PITCHES = ImmutableList.of(0.5625F, 0.625F, 0.75F, 0.9375F, 1.0F, 1.0F, 1.125F, 1.25F, 1.5F, 1.875F, 2.0F, 2.25F, new Float[]{2.5F, 3.0F, 3.75F, 4.0F});
-    private final DynamicGameEventListener<VibrationSystem.Listener> dynamicVibrationListener;
+    private final DynamicGameEventListener<VibrationSystem.Listener> dynamicVibrationListener; public VibrationSystem.Listener getVibrationListener() { return dynamicVibrationListener.getListener(); } // MultiPaper - add getter
     private VibrationSystem.Data vibrationData;
     private final VibrationSystem.User vibrationUser;
     private final DynamicGameEventListener<Allay.JukeboxListener> dynamicJukeboxListener;
@@ -714,7 +715,7 @@ public class Allay extends PathfinderMob implements InventoryCarrier, VibrationS
         }
     }
 
-    private class JukeboxListener implements GameEventListener {
+    class JukeboxListener implements GameEventListener, MultiPaperGameEventHandler.SourceContainer { // MultiPaper - get allay
 
         private final PositionSource listenerSource;
         private final int listenerRadius;
@@ -746,5 +747,7 @@ public class Allay extends PathfinderMob implements InventoryCarrier, VibrationS
                 return false;
             }
         }
+
+        @Override public Object getSource() { return Allay.this; } // MultiPaper - get allay
     }
 }
diff --git a/src/main/java/net/minecraft/world/entity/monster/warden/Warden.java b/src/main/java/net/minecraft/world/entity/monster/warden/Warden.java
index 3fa46affc4d77d01909cfeaeaba6e06ba9fd5592..dc928dad2694d980d1fd0f117194584fe43afec4 100644
--- a/src/main/java/net/minecraft/world/entity/monster/warden/Warden.java
+++ b/src/main/java/net/minecraft/world/entity/monster/warden/Warden.java
@@ -106,7 +106,7 @@ public class Warden extends Monster implements VibrationSystem {
     public AnimationState diggingAnimationState = new AnimationState();
     public AnimationState attackAnimationState = new AnimationState();
     public AnimationState sonicBoomAnimationState = new AnimationState();
-    private final DynamicGameEventListener<VibrationSystem.Listener> dynamicGameEventListener = new DynamicGameEventListener<>(new VibrationSystem.Listener(this));
+    private final DynamicGameEventListener<VibrationSystem.Listener> dynamicGameEventListener = new DynamicGameEventListener<>(new VibrationSystem.Listener(this)); public VibrationSystem.Listener getVibrationListener() { return dynamicGameEventListener.getListener(); } // MultiPaper - add getter
     private final VibrationSystem.User vibrationUser = new Warden.VibrationUser();
     private VibrationSystem.Data vibrationData = new VibrationSystem.Data();
     AngerManagement angerManagement = new AngerManagement(this::canTargetEntity, Collections.emptyList());
diff --git a/src/main/java/net/minecraft/world/level/block/entity/SculkSensorBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/SculkSensorBlockEntity.java
index 5d3740875de337e24fdba28305f61e96d01c457f..a13097e4d17898713383ed3bea3db81c9c04d4ec 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/SculkSensorBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/SculkSensorBlockEntity.java
@@ -21,7 +21,7 @@ import org.slf4j.Logger;
 public class SculkSensorBlockEntity extends BlockEntity implements GameEventListener.Holder<VibrationSystem.Listener>, VibrationSystem {
     private static final Logger LOGGER = LogUtils.getLogger();
     private VibrationSystem.Data vibrationData;
-    private final VibrationSystem.Listener vibrationListener;
+    private final VibrationSystem.Listener vibrationListener; public VibrationSystem.Listener getVibrationListener() { return vibrationListener; } // MultiPaper - add getter
     private final VibrationSystem.User vibrationUser = this.createVibrationUser();
     public int lastVibrationFrequency;
     @Nullable public Integer rangeOverride = null; // Paper
diff --git a/src/main/java/net/minecraft/world/level/block/entity/SculkShriekerBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/SculkShriekerBlockEntity.java
index 5935cf23ec11ae48b6c7cec9bd696d10d808e729..5fd8eedf4445ac0d1992332ece5bdac473ba0dd8 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/SculkShriekerBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/SculkShriekerBlockEntity.java
@@ -58,7 +58,7 @@ public class SculkShriekerBlockEntity extends BlockEntity implements GameEventLi
     public int warningLevel;
     private final VibrationSystem.User vibrationUser = new SculkShriekerBlockEntity.VibrationUser();
     private VibrationSystem.Data vibrationData = new VibrationSystem.Data();
-    private final VibrationSystem.Listener vibrationListener = new VibrationSystem.Listener(this);
+    private final VibrationSystem.Listener vibrationListener = new VibrationSystem.Listener(this); public VibrationSystem.Listener getVibrationListener() { return vibrationListener; } // MultiPaper - add getter
 
     public SculkShriekerBlockEntity(BlockPos pos, BlockState state) {
         super(BlockEntityType.SCULK_SHRIEKER, pos, state);
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index cae24e0cd477df6d83561e0d300038f8c31b53b8..98ae80c2ca5e4fa6fcfef44bab75924e6439242a 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -780,7 +780,7 @@ public class LevelChunk extends ChunkAccess {
         this.removeBlockEntityTicker(pos);
     }
 
-    private <T extends BlockEntity> void removeGameEventListener(T blockEntity, ServerLevel world) {
+    public <T extends BlockEntity> void removeGameEventListener(T blockEntity, ServerLevel world) { // MultiPaper - make public
         Block block = blockEntity.getBlockState().getBlock();
 
         if (block instanceof EntityBlock) {
@@ -1188,7 +1188,7 @@ public class LevelChunk extends ChunkAccess {
         });
     }
 
-    private <T extends BlockEntity> void addGameEventListener(T blockEntity, ServerLevel world) {
+    public <T extends BlockEntity> void addGameEventListener(T blockEntity, ServerLevel world) { // MultiPaper - make public
         Block block = blockEntity.getBlockState().getBlock();
 
         if (block instanceof EntityBlock) {
diff --git a/src/main/java/net/minecraft/world/level/gameevent/GameEventDispatcher.java b/src/main/java/net/minecraft/world/level/gameevent/GameEventDispatcher.java
index f2d10d58617644a589ecec3e17358c1277795e5d..b223198fc11a9bad9c47c8c482144640a3842e37 100644
--- a/src/main/java/net/minecraft/world/level/gameevent/GameEventDispatcher.java
+++ b/src/main/java/net/minecraft/world/level/gameevent/GameEventDispatcher.java
@@ -17,6 +17,7 @@ import org.bukkit.craftbukkit.util.CraftLocation;
 import org.bukkit.craftbukkit.util.CraftNamespacedKey;
 import org.bukkit.event.world.GenericGameEvent;
 // CraftBukkit end
+import puregero.multipaper.MultiPaperGameEventHandler;
 
 public class GameEventDispatcher {
 
@@ -84,6 +85,7 @@ public class GameEventDispatcher {
             GameEvent.ListenerInfo gameevent_b = (GameEvent.ListenerInfo) iterator.next();
             GameEventListener gameeventlistener = gameevent_b.recipient();
 
+            if (MultiPaperGameEventHandler.onGameEvent(gameeventlistener, level, gameevent_b)) continue; // MultiPaper
             gameeventlistener.handleGameEvent(this.level, gameevent_b.gameEvent(), gameevent_b.context(), gameevent_b.source());
         }
 
diff --git a/src/main/java/puregero/multipaper/MultiPaper.java b/src/main/java/puregero/multipaper/MultiPaper.java
index d0586f9ed5a6cbd4e60fd444af5c8f857e747393..c5f1d62d4512d84fc3f2758da6ef23ebfc420168 100644
--- a/src/main/java/puregero/multipaper/MultiPaper.java
+++ b/src/main/java/puregero/multipaper/MultiPaper.java
@@ -5,6 +5,7 @@ import io.papermc.paper.world.ChunkEntitySlices;
 import net.minecraft.core.registries.BuiltInRegistries;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.world.Container;
+import net.minecraft.world.entity.monster.warden.WardenSpawnTracker;
 import net.minecraft.world.level.block.entity.BlockEntity;
 import net.minecraft.core.BlockPos;
 import net.minecraft.server.MinecraftServer;
@@ -97,6 +98,8 @@ public class MultiPaper {
                 } else {
                     externalPlayer.setSleepCounter(0);
                 }
+
+                externalPlayer.getWardenSpawnTracker().ifPresent(WardenSpawnTracker::tick); // WardenSpawnTracker Optional is never empty
             }
 
             player.syncExperience();
diff --git a/src/main/java/puregero/multipaper/MultiPaperChunkHandler.java b/src/main/java/puregero/multipaper/MultiPaperChunkHandler.java
index c6503af0fd03ee334c44445fe7b6ce7ba78245eb..b14a0e8d5c11a17dbf5ea0747318d5c264fd0b54 100644
--- a/src/main/java/puregero/multipaper/MultiPaperChunkHandler.java
+++ b/src/main/java/puregero/multipaper/MultiPaperChunkHandler.java
@@ -164,7 +164,9 @@ public class MultiPaperChunkHandler {
             } else if (packet instanceof ClientboundBlockEntityDataPacket update) {
                 BlockEntity existingBlockEntity = blockUpdateChunk.getBlockEntity(update.getPos());
                 if (existingBlockEntity != null && existingBlockEntity.minecraftKey.toString().equals(update.getTag().getString("id"))) {
+                    ((LevelChunk) blockUpdateChunk).removeGameEventListener(existingBlockEntity, level);
                     existingBlockEntity.load(update.getTag());
+                    ((LevelChunk) blockUpdateChunk).addGameEventListener(existingBlockEntity, level);
                     holder.vanillaChunkHolder.blockChanged(update.getPos());
                 } else if (!blockUpdateChunk.getBlockState(update.getPos()).hasBlockEntity() && depth < 1) {
                     MCUtil.scheduleTask(1, () -> handleBlockUpdate(world, packet, depth + 1));
diff --git a/src/main/java/puregero/multipaper/MultiPaperGameEventHandler.java b/src/main/java/puregero/multipaper/MultiPaperGameEventHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..b96b02d5e5be62a2aadb3623f0164885f4c8db3f
--- /dev/null
+++ b/src/main/java/puregero/multipaper/MultiPaperGameEventHandler.java
@@ -0,0 +1,74 @@
+package puregero.multipaper;
+
+import com.mojang.datafixers.util.Either;
+import io.papermc.paper.chunk.system.scheduling.NewChunkHolder;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.gameevent.GameEvent;
+import net.minecraft.world.level.gameevent.GameEventListener;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import puregero.multipaper.externalserverprotocol.GameEventPacket;
+
+import java.util.Optional;
+
+public class MultiPaperGameEventHandler {
+
+    private static final Logger LOGGER = LogManager.getLogger(MultiPaperGameEventHandler.class.getSimpleName());
+
+    public interface SourceContainer {
+        Object getSource();
+    }
+
+    public static Either<Entity, BlockEntity> getEntity(Object object) {
+        if (object instanceof Entity entity) {
+            return Either.left(entity);
+        } else if (object instanceof BlockEntity blockEntity) {
+            return Either.right(blockEntity);
+        } else if (object instanceof SourceContainer sourceContainer) {
+            return getEntity(sourceContainer.getSource());
+        } else {
+            throw new IllegalArgumentException(object + " could not be converted to either an Entity or a BlockEntity!");
+        }
+    }
+
+    public static Optional<ExternalServer> getControllingServer(Either<Entity, BlockEntity> either) {
+        return either.map(
+                entity -> {
+                    Entity controller = MultiPaperEntitiesHandler.getControllingPassenger(entity);
+                    if (controller instanceof ExternalPlayer externalPlayer) {
+                        return Optional.of(externalPlayer.externalServerConnection.externalServer);
+                    } else if (controller instanceof ServerPlayer) {
+                        return Optional.empty();
+                    } else {
+                        NewChunkHolder newChunkHolder = MultiPaper.getChunkHolder(entity);
+                        if (newChunkHolder != null && newChunkHolder.externalOwner != null && !newChunkHolder.externalOwner.isMe()) {
+                            return Optional.of(newChunkHolder.externalOwner);
+                        } else {
+                            return Optional.empty();
+                        }
+                    }
+                },
+                blockEntity -> {
+                    NewChunkHolder newChunkHolder = MultiPaper.getChunkHolder((ServerLevel) blockEntity.getLevel(), blockEntity.getBlockPos());
+                    if (newChunkHolder != null && newChunkHolder.externalOwner != null && !newChunkHolder.externalOwner.isMe()) {
+                        return Optional.of(newChunkHolder.externalOwner);
+                    } else {
+                        return Optional.empty();
+                    }
+                }
+        );
+    }
+
+    public static boolean onGameEvent(GameEventListener gameEventListener, ServerLevel world, GameEvent.ListenerInfo event) {
+        Either<Entity, BlockEntity> either = getEntity(event.context().sourceEntity());
+        Optional<ExternalServer> controllingServer = getControllingServer(either);
+
+        controllingServer.ifPresent(
+                externalServer -> externalServer.getConnection().send(new GameEventPacket(either, world, event))
+        );
+        return controllingServer.isPresent();
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
index 7436f3c9565099769c8abcb66e8ba719bec9bde8..0aa7f26833c1e572e3339c5734b7d4c53b17781a 100644
--- a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
@@ -76,6 +76,7 @@ public class ExternalServerPacketSerializer {
         addPacket(RaidJoinPacket.class, RaidJoinPacket::new);
         addPacket(SetPoiPacket.class, SetPoiPacket::new);
         addPacket(AddDeltaMovementPacket.class, AddDeltaMovementPacket::new);
+        addPacket(GameEventPacket.class, GameEventPacket::new);
     }
 
     private static void addPacket(Class<? extends ExternalServerPacket> clazz, Function<FriendlyByteBuf, ExternalServerPacket> deserializer) {
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/GameEventPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/GameEventPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..862d7120d8cc48987907c95cc902dc175d72286b
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/GameEventPacket.java
@@ -0,0 +1,132 @@
+package puregero.multipaper.externalserverprotocol;
+
+import com.mojang.datafixers.util.Either;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.animal.allay.Allay;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.gameevent.DynamicGameEventListener;
+import net.minecraft.world.level.gameevent.GameEvent;
+import net.minecraft.world.level.gameevent.GameEventListener;
+import net.minecraft.world.phys.Vec3;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+
+import java.util.Optional;
+import java.util.UUID;
+
+public class GameEventPacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(GameEventPacket.class.getSimpleName());
+
+    private final UUID world;
+    private final Either<UUID, BlockPos> id;
+    private final GameEvent gameEvent;
+    private final Vec3 sourcePos;
+    private final Optional<UUID> sourceUuid;
+    private final Optional<BlockState> affectedState;
+
+    public GameEventPacket(Either<Entity, BlockEntity> either, ServerLevel level, GameEvent.ListenerInfo gameEvent) {
+        this.world = level.getWorld().getUID();
+        this.id = either.mapBoth(
+                Entity::getUUID,
+                BlockEntity::getBlockPos
+        );
+        this.gameEvent = gameEvent.gameEvent();
+        this.sourcePos = gameEvent.source();
+        this.sourceUuid = Optional.ofNullable(gameEvent.context().sourceEntity()).map(Entity::getUUID);
+        this.affectedState = Optional.ofNullable(gameEvent.context().affectedState());
+    }
+
+    public GameEventPacket(FriendlyByteBuf in) {
+        this.world = in.readUUID();
+        if (in.readBoolean()) {
+            this.id = Either.left(in.readUUID());
+        } else {
+            this.id = Either.right(in.readBlockPos());
+        }
+        this.gameEvent = in.readById(BuiltInRegistries.GAME_EVENT);
+        this.sourcePos = new Vec3(in.readDouble(), in.readDouble(), in.readDouble());
+        this.sourceUuid = in.readOptional(FriendlyByteBuf::readUUID);
+        this.affectedState = in.readOptional(buf -> buf.readById(Block.BLOCK_STATE_REGISTRY));
+    }
+
+    @Override
+    public void write(FriendlyByteBuf out) {
+        out.writeUUID(this.world);
+        out.writeBoolean(this.id.left().isPresent());
+        this.id.ifLeft(out::writeUUID);
+        this.id.ifRight(out::writeBlockPos);
+        out.writeId(BuiltInRegistries.GAME_EVENT, this.gameEvent);
+        out.writeDouble(this.sourcePos.x());
+        out.writeDouble(this.sourcePos.y());
+        out.writeDouble(this.sourcePos.z());
+        out.writeOptional(this.sourceUuid, FriendlyByteBuf::writeUUID);
+        out.writeOptional(this.affectedState, (buf, value) -> buf.writeId(Block.BLOCK_STATE_REGISTRY, value));
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        MultiPaper.runSync(() -> {
+            ServerLevel level = ((CraftWorld) Bukkit.getWorld(this.world)).getHandle();
+            Object entity = resolveId(level);
+            if (entity == null) {
+                LOGGER.warn("Could not find entity for " + this.id);
+                return;
+            }
+
+            if (entity instanceof Allay allay) {
+                allay.updateDynamicGameEventListener(
+                        (dynamicGameEventListener, serverLevel) -> handleGameEvent(dynamicGameEventListener.getListener(), level, entity)
+                );
+            } else {
+                GameEventListener gameEventListener = getGameEventListener(entity);
+                handleGameEvent(gameEventListener, level, entity);
+            }
+        });
+    }
+
+    private void handleGameEvent(GameEventListener gameEventListener, ServerLevel level, Object entity) {
+        gameEventListener.handleGameEvent(level, gameEvent, GameEvent.Context.of(sourceUuid.map(level::getEntity).orElse(null), affectedState.orElse(null)), sourcePos);
+    }
+
+    private GameEventListener getGameEventListener(Object entity) {
+        if (entity instanceof GameEventListener gameEventListener) {
+            return gameEventListener;
+        } else if (entity instanceof DynamicGameEventListener<?> dynamicGameEventListener) {
+            return dynamicGameEventListener.getListener();
+        } else {
+            throw new IllegalArgumentException("Could not figure out how to convert " + entity + " to a GameEventListener");
+        }
+    }
+
+    private Vec3 getPos(Object object) {
+        if (object instanceof Entity entity) {
+            return entity.position();
+        } else if (object instanceof BlockEntity blockEntity) {
+            return new Vec3(blockEntity.getBlockPos().getX() + 0.5, blockEntity.getBlockPos().getY(), blockEntity.getBlockPos().getZ() + 0.5);
+        } else {
+            throw new IllegalArgumentException(object + " could not be converted to either an Entity or a BlockEntity to get it's position!");
+        }
+    }
+
+    private Object resolveId(ServerLevel level) {
+        return this.id.map(
+                level::getEntity,
+                blockPos -> {
+                    LevelChunk levelChunk = level.getChunkIfLoaded(blockPos);
+                    return levelChunk == null ? null : levelChunk.getBlockEntity(blockPos);
+                }
+        );
+    }
+}
